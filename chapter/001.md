# Chapter 1: Arithmetic Expressions

By the end of this chapter, you'll have a working calculator that parses and evaluates expressions like `1 + 2 * 3`. Along the way, we'll set up the project structure, build a REPL, learn how to define an abstract syntax tree, write a parser with megaparsec, and evaluate expressions by walking the tree. This is a common first step in learning to write an interpreter. If you've seen this before, you may want to skip ahead.

## The REPL

Every language needs a way to run code. We'll start with a REPL — a read-eval-print loop — the simplest possible interface. Type an expression, see the result.

Before we can parse or evaluate anything, let's get the loop itself working. We'll use [haskeline](https://hackage.haskell.org/package/haskeline) for line editing, so you get arrow-key history and cursor movement for free.

```haskell
-- app/Main.hs
module Main (main) where

import System.Console.Haskeline

main :: IO ()
main = do
  putStrLn "Helium Chapter 1 - Type an expression (Ctrl-D to quit)"
  runInputT defaultSettings repl

repl :: InputT IO ()
repl = do
  minput <- getInputLine "h> "
  case minput of
    Nothing -> outputStrLn ""
    Just input -> do
      outputStrLn input
      repl
```

This doesn't do anything useful yet — it just echoes your input back. But the structure is already here:

1. `getInputLine` prints the prompt and reads a line. It returns `Nothing` when the user presses Ctrl-D (end of input), and `Just input` otherwise.
2. We pattern match on the result: quit on `Nothing`, process the input on `Just`.
3. After processing, call `repl` again to loop.

`InputT IO` is a **monad transformer** — it layers haskeline's input capabilities on top of regular `IO`. If you don't know what that means, but would like to, the [System F Functional Programming Course]() is excellent. In practice it just means you use `outputStrLn` instead of `putStrLn`, and the rest works like normal `IO`. We'll come back to monad transformers when we need them for something more interesting.

To add haskeline to the project, we add it to the executable's dependencies in the cabal file:

```cabal
executable helium
    import:           warnings
    main-is:          Main.hs
    build-depends:    base >=4.14 && <5
                    , helium
                    , haskeline >= 0.8
    hs-source-dirs:   app
    default-language: GHC2021
```

Build and run:

```
$ cabal run helium
Helium Chapter 1 - Type an expression (Ctrl-D to quit)
h> hello
hello
h>
```

It echoes. It loops. It quits on Ctrl-D. That's a REPL. Now let's give it something to do.

## Abstract Syntax

When you write `1 + 2 * 3`, that's _concrete syntax_ — a string of characters. To evaluate it, we need to turn it into a data structure that captures the _meaning_: "add 1 to the result of multiplying 2 and 3."

That data structure is called an **abstract syntax tree** (AST). Here's ours:

```haskell
-- src/Helium/Syntax.hs
module Helium.Syntax where

data Expr
  = Lit Int
  | Neg Expr
  | Add Expr Expr
  | Sub Expr Expr
  | Mul Expr Expr
  | Div Expr Expr
  deriving (Show, Eq)
```

Each constructor represents one kind of expression:

- `Lit 42` is the integer literal `42`
- `Neg e` is negation: `-e`
- `Add a b` is addition: `a + b`
- And so on for `Sub`, `Mul`, `Div`

The expression `1 + 2 * 3` becomes:

```
Add (Lit 1) (Mul (Lit 2) (Lit 3))
```

Notice that the tree already encodes operator precedence — `Mul` is nested inside `Add`, so it evaluates first. The concrete syntax `1 + 2 * 3` is ambiguous without precedence rules; the AST is not.

We derive `Show` so we can print the tree (useful for debugging), and `Eq` so we can test equality later.

## The Parser

The parser's job is to turn a string like `"1 + 2 * 3"` into an AST like `Add (Lit 1) (Mul (Lit 2) (Lit 3))`. We'll use [megaparsec](https://hackage.haskell.org/package/megaparsec), a parser combinator library.

**Parser combinators** let you build complex parsers by composing small ones. Instead of writing a grammar in a separate file and running a code generator (like yacc or ANTLR), you write parsers as ordinary Haskell functions and combine them with operators like `<|>` (try this or that) and `<*>` (do this then that).

Here's the full parser:

```haskell
-- src/Helium/Parser.hs
module Helium.Parser (parseExpr) where

import Control.Arrow (left)
import Control.Monad.Combinators.Expr (Operator (InfixL, Prefix), makeExprParser)
import Data.Void (Void)
import Helium.Syntax (Expr (..))
import Text.Megaparsec
import Text.Megaparsec.Char (char, space1, string)
import Text.Megaparsec.Char.Lexer qualified as L

type Parser = Parsec Void String

-- greedy space consumer
sc :: Parser ()
sc = L.space space1 empty empty

lexeme :: Parser a -> Parser a
lexeme = L.lexeme sc

integer :: Parser Int
integer = lexeme L.decimal

parens :: Parser a -> Parser a
parens = between (lexeme (char '(')) (lexeme (char ')'))

prefix :: String -> (Expr -> Expr) -> Operator Parser Expr
prefix name f = Prefix (f <$ lexeme (string name))

binary :: String -> (Expr -> Expr -> Expr) -> Operator Parser Expr
binary name f = InfixL (f <$ lexeme (string name))

operatorTable :: [[Operator Parser Expr]]
operatorTable =
  [ [prefix "-" Neg],
    [binary "*" Mul, binary "/" Div],
    [binary "+" Add, binary "-" Sub]
  ]

term :: Parser Expr
term = parens expr <|> Lit <$> integer

expr :: Parser Expr
expr = makeExprParser term operatorTable

parseExpr :: String -> Either String Expr
parseExpr input =
  left errorBundlePretty $
    parse (sc *> expr <* eof) "<stdin>" input
```

That's a lot of pieces. Let's go through them.

### The type

```haskell
type Parser = Parsec Void String
```

`Parsec` is megaparsec's parser type. It takes two type parameters: the **custom error type** (we use `Void` because we don't have custom errors yet) and the **input stream type** (`String` — we're parsing strings).

### Whitespace handling

```haskell
sc :: Parser ()
sc = L.space space1 empty empty

lexeme :: Parser a -> Parser a
lexeme = L.lexeme sc
```

Handling whitespace is one of those things that's easy to get wrong. Megaparsec's convention is:

1. Define a **space consumer** (`sc`) that eats whitespace, line comments, and block comments. We only have whitespace for now, so the comment parsers are `empty` (always fails — no comments to parse).
2. Wrap every token parser in `lexeme`, which runs the parser and then consumes trailing whitespace.
3. Consume leading whitespace once at the top level (the `sc *>` in `parseExpr`).

This way, individual parsers never worry about spaces.

### Tokens

```haskell
integer :: Parser Int
integer = lexeme L.decimal

parens :: Parser a -> Parser a
parens = between (lexeme (char '(')) (lexeme (char ')'))
```

`L.decimal` parses a non-negative integer. Wrapped in `lexeme`, it also eats trailing spaces. `parens` parses something between `(` and `)`.

### Operators and precedence

This is the heart of the parser:

```haskell
operatorTable :: [[Operator Parser Expr]]
operatorTable =
  [ [prefix "-" Neg],
    [binary "*" Mul, binary "/" Div],
    [binary "+" Add, binary "-" Sub]
  ]
```

`makeExprParser` from the `parser-combinators` package takes a "term" parser and an operator table, and builds a full expression parser with correct precedence and associativity.

The table is a list of lists. Each inner list is a **precedence level**, from highest (binds tightest) to lowest:

1. Prefix negation (`-`) — highest precedence
2. Multiplication and division
3. Addition and subtraction — lowest precedence

So `1 + 2 * 3` parses as `Add (Lit 1) (Mul (Lit 2) (Lit 3))` because `*` is in a higher precedence group than `+`.

`InfixL` means left-associative: `1 - 2 - 3` parses as `Sub (Sub (Lit 1) (Lit 2)) (Lit 3)`, i.e. `(1 - 2) - 3`. This matches standard arithmetic.

The helper functions `prefix` and `binary` are small wrappers that construct `Operator` values:

```haskell
prefix :: String -> (Expr -> Expr) -> Operator Parser Expr
prefix name f = Prefix (f <$ lexeme (string name))

binary :: String -> (Expr -> Expr -> Expr) -> Operator Parser Expr
binary name f = InfixL (f <$ lexeme (string name))
```

`Prefix` and `InfixL` are constructors from `parser-combinators` that tell `makeExprParser` how the operator is used. Each one wraps a parser that recognises the operator token and returns the AST constructor to apply.

The `<$` operator is worth knowing: `f <$ p` runs parser `p`, throws away its result, and returns `f` instead. So `Neg <$ lexeme (string "-")` parses a `-` sign and returns the `Neg` constructor.

### Putting it together

```haskell
term :: Parser Expr
term = parens expr <|> Lit <$> integer

expr :: Parser Expr
expr = makeExprParser term operatorTable
```

A **term** is either a parenthesised expression or an integer literal. An **expression** is terms connected by operators. Note the mutual recursion: `term` calls `expr` (via `parens expr`), and `expr` calls `term` (via `makeExprParser`). This is what lets parentheses nest arbitrarily deep.

### The entry point

```haskell
parseExpr :: String -> Either String Expr
parseExpr input =
  left errorBundlePretty $
    parse (sc *> expr <* eof) "<stdin>" input
```

`parse` runs a parser on an input string. The second argument (`"<stdin>"`) is the source name — it shows up in error messages so you know which file an error came from. It will become more useful when we start parsing files.

`sc *> expr <* eof` means: consume leading whitespace, parse an expression, then expect end of input. Without `eof`, the parser would succeed on `"1 + 2 hello"` by parsing `1 + 2` and silently ignoring the rest.

`parse` returns `Either (ParseErrorBundle String Void) Expr`. We use `left errorBundlePretty` to convert the error bundle into a readable `String`. `left` from `Control.Arrow` maps a function over the `Left` side of an `Either` — it's the `Either` equivalent of `fmap` for the error case.

### Wiring the parser into the REPL

With the parser ready, we can update Main to use it:

```haskell
-- app/Main.hs
module Main (main) where

import Helium.Parser (parseExpr)
import System.Console.Haskeline

main :: IO ()
main = do
  putStrLn "Helium Chapter 1 - Type an expression (Ctrl-D to quit)"
  runInputT defaultSettings repl

repl :: InputT IO ()
repl = do
  minput <- getInputLine "h> "
  case minput of
    Nothing -> outputStrLn ""
    Just input -> do
      case parseExpr input of
        Right expr -> outputStrLn $ show expr
        Left err -> outputStrLn $ "Error: " <> err
      repl
```

Now we can see the AST:

```
$ cabal run helium
h> 1 + 2 * 3
Add (Lit 1) (Mul (Lit 2) (Lit 3))
h> (1 + 2) * 3
Mul (Add (Lit 1) (Lit 2)) (Lit 3)
h> hello
Error: <stdin>:1:1:
  |
1 | hello
  | ^
unexpected 'h'
expecting '(', '-', or integer
```

The tree structure confirms that precedence is working, and megaparsec gives us clear error messages pointing to exactly where parsing failed.

## The Evaluator

We have a tree. Now we need to compute its value. This is the simplest part — a recursive function that pattern-matches on each node:

```haskell
-- src/Helium/Eval.hs
module Helium.Eval (eval) where

import Helium.Syntax (Expr (..))

eval :: Expr -> Int
eval expr = case expr of
  (Lit n) -> n
  (Neg e) -> negate (eval e)
  (Add a b) -> eval a + eval b
  (Sub a b) -> eval a - eval b
  (Mul a b) -> eval a * eval b
  (Div a b) -> eval a `div` eval b
```

This is a **tree-walk evaluator** — it walks the AST recursively, computing results bottom-up. For `Add (Lit 1) (Mul (Lit 2) (Lit 3))`:

1. Evaluate the left child: `Lit 1` → `1`
2. Evaluate the right child: `Mul (Lit 2) (Lit 3)`
   - Evaluate `Lit 2` → `2`
   - Evaluate `Lit 3` → `3`
   - Multiply: `6`
3. Add: `1 + 6` → `7`

We use `div` for integer division (truncating toward negative infinity). There's no error handling for division by zero — that'll crash. We'll address error handling properly in a later chapter when we have more to handle.

### The complete REPL

With the evaluator, the REPL now prints both the AST and the result:

```haskell
-- app/Main.hs
module Main (main) where

import Helium.Eval (eval)
import Helium.Parser (parseExpr)
import System.Console.Haskeline

main :: IO ()
main = do
  putStrLn "Helium Chapter 1 - Type an expression (Ctrl-D to quit)"
  runInputT defaultSettings repl

repl :: InputT IO ()
repl = do
  minput <- getInputLine "h> "
  case minput of
    Nothing -> outputStrLn ""
    Just input -> do
      case parseExpr input of
        Right expr -> do
          outputStrLn $ show expr
          outputStrLn . show $ eval expr
        Left err -> outputStrLn $ "Error: " <> err
      repl
```

```
$ cabal run helium
Helium Chapter 1 - Type an expression (Ctrl-D to quit)
h> 1 + 2 * 3
Add (Lit 1) (Mul (Lit 2) (Lit 3))
7
h> (10 - 3) * (2 + 4)
Mul (Sub (Lit 10) (Lit 3)) (Add (Lit 2) (Lit 4))
42
h> -5
Neg (Lit 5)
-5
```

## What we built

Four files, 94 lines of code, and a working calculator:

| File            | Purpose                                                 |
| --------------- | ------------------------------------------------------- |
| `Helium.Syntax` | The AST — a data type representing expression structure |
| `Helium.Parser` | Turns strings into ASTs using megaparsec                |
| `Helium.Eval`   | Walks the AST to compute a result                       |
| `Main`          | The REPL loop — reads, parses, evaluates, prints        |

This is the skeleton of every interpreter. The pieces will get more complex — the AST will grow, the parser will handle more syntax, the evaluator will need environments and closures — but the pipeline stays the same: **parse → AST → evaluate**.

In the next chapter, we'll add variables and `let` bindings, which means the evaluator will need to track names and their values. That's where things start to get interesting.
